"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_utils_analytics_ts",{

/***/ "(app-pages-browser)/./src/utils/analytics.ts":
/*!********************************!*\
  !*** ./src/utils/analytics.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   processOrderSizes: function() { return /* binding */ processOrderSizes; },\n/* harmony export */   processPriceRanges: function() { return /* binding */ processPriceRanges; },\n/* harmony export */   processProductCategories: function() { return /* binding */ processProductCategories; },\n/* harmony export */   processProductTypes: function() { return /* binding */ processProductTypes; }\n/* harmony export */ });\nconst isNotShippingProtection = (item)=>{\n    const product = item.node.product;\n    if (!product) return true;\n    const productType = (product.productType || \"\").toLowerCase();\n    const productTitle = item.node.title.toLowerCase();\n    return ![\n        \"shipping\",\n        \"protection\",\n        \"insurance\"\n    ].some((term)=>productType.includes(term) || productTitle.includes(term));\n};\nconst processOrderSizes = (orders)=>{\n    const sizes = orders.map((order)=>order.lineItems.edges.filter(isNotShippingProtection).reduce((sum, item)=>sum + item.node.quantity, 0));\n    const sizeMap = new Map();\n    sizes.forEach((size)=>{\n        sizeMap.set(size, (sizeMap.get(size) || 0) + 1);\n    });\n    return Array.from(sizeMap.entries()).map((param)=>{\n        let [size, count] = param;\n        return {\n            name: \"\".concat(size, \" \").concat(size === 1 ? \"item\" : \"items\"),\n            value: count\n        };\n    }).sort((a, b)=>parseInt(a.name) - parseInt(b.name));\n};\nconst processPriceRanges = function(orders) {\n    let range = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 30;\n    const prices = orders.map((order)=>parseFloat(order.totalPriceSet.shopMoney.amount)).sort((a, b)=>a - b);\n    const percentile90 = prices[Math.floor(prices.length * 0.9)];\n    const maxPrice = Math.ceil(percentile90 / range) * range;\n    const minPrice = Math.floor(Math.min(...prices) / range) * range;\n    const ranges = [];\n    for(let i = minPrice; i < maxPrice; i += range){\n        ranges.push({\n            min: i,\n            max: i + range\n        });\n    }\n    ranges.push({\n        min: maxPrice,\n        max: Infinity\n    });\n    const rangeCounts = ranges.map((range)=>({\n            name: range.max === Infinity ? \"$\".concat(range.min, \"+\") : \"$\".concat(range.min, \"-$\").concat(range.max),\n            value: prices.filter((price)=>price >= range.min && price < range.max).length\n        }));\n    return rangeCounts;\n};\nconst processProductCategories = (orders)=>{\n    const categories = new Map();\n    orders.forEach((order)=>{\n        order.lineItems.edges.filter(isNotShippingProtection).forEach((item)=>{\n            var _item_node_product_category, _item_node_product;\n            const category = ((_item_node_product = item.node.product) === null || _item_node_product === void 0 ? void 0 : (_item_node_product_category = _item_node_product.category) === null || _item_node_product_category === void 0 ? void 0 : _item_node_product_category.name) || \"Unknown\";\n            categories.set(category, (categories.get(category) || 0) + item.node.quantity);\n        });\n    });\n    return Array.from(categories.entries()).map((param)=>{\n        let [name, value] = param;\n        return {\n            name,\n            value\n        };\n    }).sort((a, b)=>b.value - a.value);\n};\nconst processProductTypes = (orders)=>{\n    const types = new Map();\n    orders.forEach((order)=>{\n        order.lineItems.edges.filter(isNotShippingProtection).forEach((item)=>{\n            var _item_node_product;\n            const type = ((_item_node_product = item.node.product) === null || _item_node_product === void 0 ? void 0 : _item_node_product.productType) || \"Undefined\";\n            types.set(type, (types.get(type) || 0) + item.node.quantity);\n        });\n    });\n    return Array.from(types.entries()).map((param)=>{\n        let [name, value] = param;\n        return {\n            name,\n            value\n        };\n    }).sort((a, b)=>b.value - a.value);\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9hbmFseXRpY3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUVBLE1BQU1BLDBCQUEwQixDQUFDQztJQUMvQixNQUFNQyxVQUFVRCxLQUFLRSxJQUFJLENBQUNELE9BQU87SUFDakMsSUFBSSxDQUFDQSxTQUFTLE9BQU87SUFFckIsTUFBTUUsY0FBYyxDQUFDRixRQUFRRSxXQUFXLElBQUksRUFBQyxFQUFHQyxXQUFXO0lBQzNELE1BQU1DLGVBQWVMLEtBQUtFLElBQUksQ0FBQ0ksS0FBSyxDQUFDRixXQUFXO0lBRWhELE9BQU8sQ0FBQztRQUFDO1FBQVk7UUFBYztLQUFZLENBQUNHLElBQUksQ0FBQ0MsQ0FBQUEsT0FDbkRMLFlBQVlNLFFBQVEsQ0FBQ0QsU0FBU0gsYUFBYUksUUFBUSxDQUFDRDtBQUV4RDtBQUVPLE1BQU1FLG9CQUFvQixDQUFDQztJQUNoQyxNQUFNQyxRQUFRRCxPQUFPRSxHQUFHLENBQUNDLENBQUFBLFFBQ3ZCQSxNQUFNQyxTQUFTLENBQUNDLEtBQUssQ0FDbEJDLE1BQU0sQ0FBQ2xCLHlCQUNQbUIsTUFBTSxDQUFDLENBQUNDLEtBQUtuQixPQUFTbUIsTUFBTW5CLEtBQUtFLElBQUksQ0FBQ2tCLFFBQVEsRUFBRTtJQUdyRCxNQUFNQyxVQUFVLElBQUlDO0lBQ3BCVixNQUFNVyxPQUFPLENBQUNDLENBQUFBO1FBQ1pILFFBQVFJLEdBQUcsQ0FBQ0QsTUFBTSxDQUFDSCxRQUFRSyxHQUFHLENBQUNGLFNBQVMsS0FBSztJQUMvQztJQUVBLE9BQU9HLE1BQU1DLElBQUksQ0FBQ1AsUUFBUVEsT0FBTyxJQUM5QmhCLEdBQUcsQ0FBQztZQUFDLENBQUNXLE1BQU1NLE1BQU07ZUFBTTtZQUN2QkMsTUFBTSxHQUFXUCxPQUFSQSxNQUFLLEtBQWlDLE9BQTlCQSxTQUFTLElBQUksU0FBUztZQUN2Q1EsT0FBT0Y7UUFDVDtJQUFBLEdBQ0NHLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNQyxTQUFTRixFQUFFSCxJQUFJLElBQUlLLFNBQVNELEVBQUVKLElBQUk7QUFDdEQsRUFBRTtBQUVLLE1BQU1NLHFCQUFxQixTQUFDMUI7UUFBd0IyQix5RUFBUTtJQUNqRSxNQUFNQyxTQUFTNUIsT0FBT0UsR0FBRyxDQUFDQyxDQUFBQSxRQUN4QjBCLFdBQVcxQixNQUFNMkIsYUFBYSxDQUFDQyxTQUFTLENBQUNDLE1BQU0sR0FDL0NWLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxJQUFJQztJQUVyQixNQUFNUyxlQUFlTCxNQUFNLENBQUNNLEtBQUtDLEtBQUssQ0FBQ1AsT0FBT1EsTUFBTSxHQUFHLEtBQUs7SUFDNUQsTUFBTUMsV0FBV0gsS0FBS0ksSUFBSSxDQUFDTCxlQUFlTixTQUFTQTtJQUNuRCxNQUFNWSxXQUFXTCxLQUFLQyxLQUFLLENBQUNELEtBQUtNLEdBQUcsSUFBSVosVUFBVUQsU0FBU0E7SUFFM0QsTUFBTWMsU0FBeUMsRUFBRTtJQUNqRCxJQUFLLElBQUlDLElBQUlILFVBQVVHLElBQUlMLFVBQVVLLEtBQUtmLE1BQU87UUFDL0NjLE9BQU9FLElBQUksQ0FBQztZQUFFSCxLQUFLRTtZQUFHRSxLQUFLRixJQUFJZjtRQUFNO0lBQ3ZDO0lBQ0FjLE9BQU9FLElBQUksQ0FBQztRQUFFSCxLQUFLSDtRQUFVTyxLQUFLQztJQUFTO0lBRTNDLE1BQU1DLGNBQWNMLE9BQU92QyxHQUFHLENBQUN5QixDQUFBQSxRQUFVO1lBQ3ZDUCxNQUFNTyxNQUFNaUIsR0FBRyxLQUFLQyxXQUFXLElBQWMsT0FBVmxCLE1BQU1hLEdBQUcsRUFBQyxPQUFLLElBQWtCYixPQUFkQSxNQUFNYSxHQUFHLEVBQUMsTUFBYyxPQUFWYixNQUFNaUIsR0FBRztZQUM3RXZCLE9BQU9PLE9BQU90QixNQUFNLENBQUN5QyxDQUFBQSxRQUFTQSxTQUFTcEIsTUFBTWEsR0FBRyxJQUFJTyxRQUFRcEIsTUFBTWlCLEdBQUcsRUFBRVIsTUFBTTtRQUMvRTtJQUVBLE9BQU9VO0FBQ1QsRUFBRTtBQUVLLE1BQU1FLDJCQUEyQixDQUFDaEQ7SUFDdkMsTUFBTWlELGFBQWEsSUFBSXRDO0lBRXZCWCxPQUFPWSxPQUFPLENBQUNULENBQUFBO1FBQ2JBLE1BQU1DLFNBQVMsQ0FBQ0MsS0FBSyxDQUNsQkMsTUFBTSxDQUFDbEIseUJBQ1B3QixPQUFPLENBQUN2QixDQUFBQTtnQkFDVUEsNkJBQUFBO1lBQWpCLE1BQU02RCxXQUFXN0QsRUFBQUEscUJBQUFBLEtBQUtFLElBQUksQ0FBQ0QsT0FBTyxjQUFqQkQsMENBQUFBLDhCQUFBQSxtQkFBbUI2RCxRQUFRLGNBQTNCN0Qsa0RBQUFBLDRCQUE2QitCLElBQUksS0FBSTtZQUN0RDZCLFdBQVduQyxHQUFHLENBQUNvQyxVQUFVLENBQUNELFdBQVdsQyxHQUFHLENBQUNtQyxhQUFhLEtBQUs3RCxLQUFLRSxJQUFJLENBQUNrQixRQUFRO1FBQy9FO0lBQ0o7SUFFQSxPQUFPTyxNQUFNQyxJQUFJLENBQUNnQyxXQUFXL0IsT0FBTyxJQUNqQ2hCLEdBQUcsQ0FBQztZQUFDLENBQUNrQixNQUFNQyxNQUFNO2VBQU07WUFBRUQ7WUFBTUM7UUFBTTtJQUFBLEdBQ3RDQyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRUgsS0FBSyxHQUFHRSxFQUFFRixLQUFLO0FBQ3JDLEVBQUU7QUFFSyxNQUFNOEIsc0JBQXNCLENBQUNuRDtJQUNsQyxNQUFNb0QsUUFBUSxJQUFJekM7SUFFbEJYLE9BQU9ZLE9BQU8sQ0FBQ1QsQ0FBQUE7UUFDYkEsTUFBTUMsU0FBUyxDQUFDQyxLQUFLLENBQ2xCQyxNQUFNLENBQUNsQix5QkFDUHdCLE9BQU8sQ0FBQ3ZCLENBQUFBO2dCQUNNQTtZQUFiLE1BQU1nRSxPQUFPaEUsRUFBQUEscUJBQUFBLEtBQUtFLElBQUksQ0FBQ0QsT0FBTyxjQUFqQkQseUNBQUFBLG1CQUFtQkcsV0FBVyxLQUFJO1lBQy9DNEQsTUFBTXRDLEdBQUcsQ0FBQ3VDLE1BQU0sQ0FBQ0QsTUFBTXJDLEdBQUcsQ0FBQ3NDLFNBQVMsS0FBS2hFLEtBQUtFLElBQUksQ0FBQ2tCLFFBQVE7UUFDN0Q7SUFDSjtJQUVBLE9BQU9PLE1BQU1DLElBQUksQ0FBQ21DLE1BQU1sQyxPQUFPLElBQzVCaEIsR0FBRyxDQUFDO1lBQUMsQ0FBQ2tCLE1BQU1DLE1BQU07ZUFBTTtZQUFFRDtZQUFNQztRQUFNO0lBQUEsR0FDdENDLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFSCxLQUFLLEdBQUdFLEVBQUVGLEtBQUs7QUFDckMsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbHMvYW5hbHl0aWNzLnRzPzViZTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2hvcGlmeU9yZGVyIH0gZnJvbSAnQC90eXBlcy9zaG9waWZ5JztcblxuY29uc3QgaXNOb3RTaGlwcGluZ1Byb3RlY3Rpb24gPSAoaXRlbTogU2hvcGlmeU9yZGVyWydsaW5lSXRlbXMnXVsnZWRnZXMnXVswXSkgPT4ge1xuICBjb25zdCBwcm9kdWN0ID0gaXRlbS5ub2RlLnByb2R1Y3Q7XG4gIGlmICghcHJvZHVjdCkgcmV0dXJuIHRydWU7XG4gIFxuICBjb25zdCBwcm9kdWN0VHlwZSA9IChwcm9kdWN0LnByb2R1Y3RUeXBlIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBwcm9kdWN0VGl0bGUgPSBpdGVtLm5vZGUudGl0bGUudG9Mb3dlckNhc2UoKTtcbiAgXG4gIHJldHVybiAhWydzaGlwcGluZycsICdwcm90ZWN0aW9uJywgJ2luc3VyYW5jZSddLnNvbWUodGVybSA9PiBcbiAgICBwcm9kdWN0VHlwZS5pbmNsdWRlcyh0ZXJtKSB8fCBwcm9kdWN0VGl0bGUuaW5jbHVkZXModGVybSlcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwcm9jZXNzT3JkZXJTaXplcyA9IChvcmRlcnM6IFNob3BpZnlPcmRlcltdKSA9PiB7XG4gIGNvbnN0IHNpemVzID0gb3JkZXJzLm1hcChvcmRlciA9PiBcbiAgICBvcmRlci5saW5lSXRlbXMuZWRnZXNcbiAgICAgIC5maWx0ZXIoaXNOb3RTaGlwcGluZ1Byb3RlY3Rpb24pXG4gICAgICAucmVkdWNlKChzdW0sIGl0ZW0pID0+IHN1bSArIGl0ZW0ubm9kZS5xdWFudGl0eSwgMClcbiAgKTtcblxuICBjb25zdCBzaXplTWFwID0gbmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKTtcbiAgc2l6ZXMuZm9yRWFjaChzaXplID0+IHtcbiAgICBzaXplTWFwLnNldChzaXplLCAoc2l6ZU1hcC5nZXQoc2l6ZSkgfHwgMCkgKyAxKTtcbiAgfSk7XG5cbiAgcmV0dXJuIEFycmF5LmZyb20oc2l6ZU1hcC5lbnRyaWVzKCkpXG4gICAgLm1hcCgoW3NpemUsIGNvdW50XSkgPT4gKHtcbiAgICAgIG5hbWU6IGAke3NpemV9ICR7c2l6ZSA9PT0gMSA/ICdpdGVtJyA6ICdpdGVtcyd9YCxcbiAgICAgIHZhbHVlOiBjb3VudFxuICAgIH0pKVxuICAgIC5zb3J0KChhLCBiKSA9PiBwYXJzZUludChhLm5hbWUpIC0gcGFyc2VJbnQoYi5uYW1lKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcHJvY2Vzc1ByaWNlUmFuZ2VzID0gKG9yZGVyczogU2hvcGlmeU9yZGVyW10sIHJhbmdlID0gMzApID0+IHtcbiAgY29uc3QgcHJpY2VzID0gb3JkZXJzLm1hcChvcmRlciA9PiBcbiAgICBwYXJzZUZsb2F0KG9yZGVyLnRvdGFsUHJpY2VTZXQuc2hvcE1vbmV5LmFtb3VudClcbiAgKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG5cbiAgY29uc3QgcGVyY2VudGlsZTkwID0gcHJpY2VzW01hdGguZmxvb3IocHJpY2VzLmxlbmd0aCAqIDAuOSldO1xuICBjb25zdCBtYXhQcmljZSA9IE1hdGguY2VpbChwZXJjZW50aWxlOTAgLyByYW5nZSkgKiByYW5nZTtcbiAgY29uc3QgbWluUHJpY2UgPSBNYXRoLmZsb29yKE1hdGgubWluKC4uLnByaWNlcykgLyByYW5nZSkgKiByYW5nZTtcbiAgXG4gIGNvbnN0IHJhbmdlczogeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXIgfVtdID0gW107XG4gIGZvciAobGV0IGkgPSBtaW5QcmljZTsgaSA8IG1heFByaWNlOyBpICs9IHJhbmdlKSB7XG4gICAgcmFuZ2VzLnB1c2goeyBtaW46IGksIG1heDogaSArIHJhbmdlIH0pO1xuICB9XG4gIHJhbmdlcy5wdXNoKHsgbWluOiBtYXhQcmljZSwgbWF4OiBJbmZpbml0eSB9KTtcblxuICBjb25zdCByYW5nZUNvdW50cyA9IHJhbmdlcy5tYXAocmFuZ2UgPT4gKHtcbiAgICBuYW1lOiByYW5nZS5tYXggPT09IEluZmluaXR5ID8gYCQke3JhbmdlLm1pbn0rYCA6IGAkJHtyYW5nZS5taW59LSQke3JhbmdlLm1heH1gLFxuICAgIHZhbHVlOiBwcmljZXMuZmlsdGVyKHByaWNlID0+IHByaWNlID49IHJhbmdlLm1pbiAmJiBwcmljZSA8IHJhbmdlLm1heCkubGVuZ3RoXG4gIH0pKTtcblxuICByZXR1cm4gcmFuZ2VDb3VudHM7XG59O1xuXG5leHBvcnQgY29uc3QgcHJvY2Vzc1Byb2R1Y3RDYXRlZ29yaWVzID0gKG9yZGVyczogU2hvcGlmeU9yZGVyW10pID0+IHtcbiAgY29uc3QgY2F0ZWdvcmllcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG5cbiAgb3JkZXJzLmZvckVhY2gob3JkZXIgPT4ge1xuICAgIG9yZGVyLmxpbmVJdGVtcy5lZGdlc1xuICAgICAgLmZpbHRlcihpc05vdFNoaXBwaW5nUHJvdGVjdGlvbilcbiAgICAgIC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBjb25zdCBjYXRlZ29yeSA9IGl0ZW0ubm9kZS5wcm9kdWN0Py5jYXRlZ29yeT8ubmFtZSB8fCAnVW5rbm93bic7XG4gICAgICAgIGNhdGVnb3JpZXMuc2V0KGNhdGVnb3J5LCAoY2F0ZWdvcmllcy5nZXQoY2F0ZWdvcnkpIHx8IDApICsgaXRlbS5ub2RlLnF1YW50aXR5KTtcbiAgICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gQXJyYXkuZnJvbShjYXRlZ29yaWVzLmVudHJpZXMoKSlcbiAgICAubWFwKChbbmFtZSwgdmFsdWVdKSA9PiAoeyBuYW1lLCB2YWx1ZSB9KSlcbiAgICAuc29ydCgoYSwgYikgPT4gYi52YWx1ZSAtIGEudmFsdWUpO1xufTtcblxuZXhwb3J0IGNvbnN0IHByb2Nlc3NQcm9kdWN0VHlwZXMgPSAob3JkZXJzOiBTaG9waWZ5T3JkZXJbXSkgPT4ge1xuICBjb25zdCB0eXBlcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG5cbiAgb3JkZXJzLmZvckVhY2gob3JkZXIgPT4ge1xuICAgIG9yZGVyLmxpbmVJdGVtcy5lZGdlc1xuICAgICAgLmZpbHRlcihpc05vdFNoaXBwaW5nUHJvdGVjdGlvbilcbiAgICAgIC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBjb25zdCB0eXBlID0gaXRlbS5ub2RlLnByb2R1Y3Q/LnByb2R1Y3RUeXBlIHx8ICdVbmRlZmluZWQnO1xuICAgICAgICB0eXBlcy5zZXQodHlwZSwgKHR5cGVzLmdldCh0eXBlKSB8fCAwKSArIGl0ZW0ubm9kZS5xdWFudGl0eSk7XG4gICAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIEFycmF5LmZyb20odHlwZXMuZW50cmllcygpKVxuICAgIC5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+ICh7IG5hbWUsIHZhbHVlIH0pKVxuICAgIC5zb3J0KChhLCBiKSA9PiBiLnZhbHVlIC0gYS52YWx1ZSk7XG59OyJdLCJuYW1lcyI6WyJpc05vdFNoaXBwaW5nUHJvdGVjdGlvbiIsIml0ZW0iLCJwcm9kdWN0Iiwibm9kZSIsInByb2R1Y3RUeXBlIiwidG9Mb3dlckNhc2UiLCJwcm9kdWN0VGl0bGUiLCJ0aXRsZSIsInNvbWUiLCJ0ZXJtIiwiaW5jbHVkZXMiLCJwcm9jZXNzT3JkZXJTaXplcyIsIm9yZGVycyIsInNpemVzIiwibWFwIiwib3JkZXIiLCJsaW5lSXRlbXMiLCJlZGdlcyIsImZpbHRlciIsInJlZHVjZSIsInN1bSIsInF1YW50aXR5Iiwic2l6ZU1hcCIsIk1hcCIsImZvckVhY2giLCJzaXplIiwic2V0IiwiZ2V0IiwiQXJyYXkiLCJmcm9tIiwiZW50cmllcyIsImNvdW50IiwibmFtZSIsInZhbHVlIiwic29ydCIsImEiLCJiIiwicGFyc2VJbnQiLCJwcm9jZXNzUHJpY2VSYW5nZXMiLCJyYW5nZSIsInByaWNlcyIsInBhcnNlRmxvYXQiLCJ0b3RhbFByaWNlU2V0Iiwic2hvcE1vbmV5IiwiYW1vdW50IiwicGVyY2VudGlsZTkwIiwiTWF0aCIsImZsb29yIiwibGVuZ3RoIiwibWF4UHJpY2UiLCJjZWlsIiwibWluUHJpY2UiLCJtaW4iLCJyYW5nZXMiLCJpIiwicHVzaCIsIm1heCIsIkluZmluaXR5IiwicmFuZ2VDb3VudHMiLCJwcmljZSIsInByb2Nlc3NQcm9kdWN0Q2F0ZWdvcmllcyIsImNhdGVnb3JpZXMiLCJjYXRlZ29yeSIsInByb2Nlc3NQcm9kdWN0VHlwZXMiLCJ0eXBlcyIsInR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/analytics.ts\n"));

/***/ })

});